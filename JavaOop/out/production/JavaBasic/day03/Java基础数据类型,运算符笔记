复习:
1.Java的技术结构
	J2SE ---标准版--- 为一些简单的应用程序来提供解决方案
	J2EE ---企业版--- 为企业的团队开发提供方案
	J2ME ---微型版--- 为小型电子设备的嵌入来提供方案(几乎不用 早期Andriod基于J2ME)
2.Java的跨平台
	JVM不是跨平台,但是java是跨平台
	JVM屏蔽不同操作系统之间的差异性	
	疑问:java编译环境?
3.JDK,JRE,JVM
  JRE包含JVM 
  JDK包含的基本组件包括:
  	--- .javac -编译器,将原码转换成字节码
  		.jar -打包工具,将相关的类文件打包成一个文件
  		.javadoc -文档生成器,从原码注释中提取文档
  		.jdb - debugger查错工具
  		另外还包含jre等
      注意:32位jdk在32位和64位操作系统中均可以运行
      64位jdk只能在64位操作系统下运行
4.入门程序
	所有的Java代码写到Java文件中
	class文件名和public类名对应	
	javac编译
	java运行
	环境变量
5.关键字
	在Java中被占用有特殊含义的单词 --- 53个2个保留字---goto,const
6.标识符
	命名规则:只能由字母,中文,下划线,$组成
		       不能由数字开头
		       不能是java关键字
		       驼峰命名法
7.注释
	解释说明程序
	//
	/**/
	/***/---javadoc
8.计算机常量/字面量---整数,小数,字符,字符串,布尔,空
9.进制
	二进制:0-1,0b/0B开头 --- jdk1.7(之前不支持二进制表示法)
	八进制:0-7,0开头
	十进制:0-9 无标志默认为10进制
	十六进制:0-9,A-F(a-f),0x/0X开头

	其他进制转化为十进制:从低位次开始按位次乘以位次次幂,然后求和
	练习:
		15*4=120;若该等式成立,求进制是几进制
     -->设为n进制
                      从低位次开始按位次乘以n的位次次幂,然后求和 解方程式
10.变量
        数据类型 变量名 = 数据;		
11.数据类型
        基本类型 
     	数值型(所有数值型都是有符号数)
     		整数型
     			byte --- 1个字节 --- -128~127
     			short --- 2个字节 --- -2^15~2^15-1 
     			int --- 4个字节 --- 整数默认为int --- 大概范围-10^10~10^10
     			long --- 8个字节 --- 大概范围 -10^18~10^18 --- 需要以l/L结尾
     		浮点型
     			float --- 4个字节 大概范围 -10^38~10^38 需要以f/F作为结尾
     			double --- 8个字节 大概范围 -10^308~10^308 浮点数默认为double
     			
     	字符型  --- char --- 2个字节 --- 取值范围 0-65535 
     	     --- char类型在内存中存储的时候是以u16编码存储的
     	     --- 另一种字符表示形式'\u0000'~'\uffff'
     	     --- 转义字符:\t \r \n \\ \' \''
	     	   扩展:编码 --- 字符和数字之间的转化规则 --- 无论哪张码表,默认兼容西欧码表(前256个字符编码一样占一个字节,例如gbk中字符'A'占1个字节) 
	     		 ISO-8859-1 --- 西欧码表 --- 1个字符对应1个字节
	     		 gb2312 --- 国标码表 --- 1个字符对应2个字节 --- 
	     		        --- gbk(在gb2312基础上改进,兼容gb2312)
     				    --- 收录了常见的简体汉字以及一部分的繁体汉字	
     			 Ucicode编码体系(包含多张码表) --- utf-8(u8) --- 一个字符对应3个字节(收录了常见语言的常见字符)
     								     --- utf-16 --- 一个字符对应2个字节
     	布尔型 --- boolean --- true/false(大小随JDK版本以及操作系统版本而变化)
        
        引用类型 --- 数组,类,接口     

12.数据类型的转换

        自动转换 --- 小转大        
		             整数转小数有精度损失
		             小数转整数直接舍弃小数部分 
        强制转换 --- 大转小
	
        注意:在计算机中,所有的数据存储的都是补码形式	  
                   最高位是一个符号位,如果最高位为0表示是一个正数,如果为1表示是一个负数     
   int i = 14; --- 对于正数的原反补码三码一致
   	
   00000000 00000000 00000000 00001110 --- 原码	
	
   00000000 00000000 00000000 00001110 --- 反码
   
   00000000 00000000 00000000 00001110 --- 补码
	
   int i = -14; --- 对于负数  
	
   10000000 00000000 00000000 00001110 --- 原码
	
   11111111 11111111 11111111 11110001 --- 反码(最高位符号位不变,其余位0->1,1->0)
	
   11111111 11111111 11111111 11110010 --- 补码(在反码基础上+1)
   
   byte b = (byte)200;
   
   00000000 00000000 00000000 11001000 --- 原码
   
   00000000 00000000 00000000 11001000 --- 反码
   
   00000000 00000000 00000000 11001000 --- 补码
   
   int --> byte 舍弃前面3个字节
   
   11001000 --> 此时为补码 需转为原码计算
   
   11001000 --> 减1
   
   11000111 --> 符号位不变 按位取反
   
   10111000 --> 转为10进制数为 -56
   
        即得到
        
        整型直接量200转为byte类型的十进制值为-56
   
注意:将-0规定为这个类型的最小值
	 
	以byte类型为例
	      
    00000000 表示+0
    
    10000000 表示-0
    
由于   11111111 表示-127而byte类型的取值范围是-128~127
        
    10000000 表示-0 此时 0这个数 存在两种表示形式 显然这并不合理 
             所以硬性规定-0为该类型的最小值 即-128
   
13.运算符

	算术: + - * / % ++ -- 
		 byte/short/char在参与运算的时候会自动提升为int
		 
		 byte b = 3;
		 
		 b = (byte)(b + 3);
		 
		   整数在运算完成之后结果一定是整数
		   
		 int = 4300/1000*1000;//结果为4000
		 
		   不同的数字除以0的结果是不一样的 --- 整数/0 ArithmeticException --- 算术异常
		 
		   非零数字/0.0	非零小数/0 --- Infinity(无穷大)
		   
		 0.0/0 
		 0.0/0.0 
		 0/0.0
		 --->NaN(not a number 非数字)
		 
		 -8%3 = -2; 14%-4 = 2;(结果的符号跟左边数字的符号一致)
		 
		 ++/--自增/自减在原基础上每次+1
		 
		 int i=7;
		 int j = i++ + ++i;
		 byte/short/char可以参与++/-- 算完之后结果类型依然是原来的类型(自带强转操作)
		     
	赋值: = += -= *= /= %= &= |= ^= <<= >>= >>>=
		 除了=符号以外 其他的符号要求变量必须先有值
		 
		byte b = 3+5;正确的
		byte b = 123+10;不正确
		//3和5是两个字面量
		//如果两个字面量参与运算 由于字面量的值是确定的 所以在编译期间会进行优化(自动计算) 
		//如果是变量编译期间由于值是不确定的 所以不会自动计算
		//所以3+5会自动转为8 --> byte b = 8; 
	
	关系: == != < > <= >=
	
	逻辑:& | ! ^ && ||
	
		&:两边同真则为真
		
		|:两边同假才为假
		
		^:两边不同为真 相同为假
		
	注意:||在&&之前会导致&&被短路掉 
		
		&&在||之前不会导致||被短路
	
	位运算:& | << >> >>> ~
		 &:将两个数转为补码形式进行按位与操作
			  利用&来实现判断一个数字的奇偶性
			 i & 1 == 1;//奇数
			  计算 -6&3
			  10000110//-6的原码
			  11111001//-6的反码
			  11111010//-6的补码
			  00000011//3的补码
			  00000010//得到结果的补码(因为是正数 所以补码即原码)
			     转为十进制数得到2
			     所以-6&3=2			  
		 |:将两个数转为补码形式进行按位或操作
		 	  计算 -6|3
		 	  10000110//-6的原码
			  11111001//-6的反码
			  11111010//-6的补码
			  00000011//3的补码
			  11111011//得到结果的补码 因为结果为负数所以需要转为原码
			  11111010//得到结果的反码
			  10000101//得到结果的原码 -5
		   参与运算的是补码
		 <<:左移几位相当于乘以2的几次方
		 >>:右移几位相当于除了2的几次方 --- 对于正数补0,负数补1(正数最大到0负数最大到-1)
                                                       (因为正数最大高位全是0,负数最大高位全是1)
		  在计算左移和右移的时候,移动(位数%32)
		 20<<34 = 20 << (34%32) = 80;
		 >>>无符号右移:无论正负一律补0(负数无符号右移 之前的负数越大 无符号右移之后的值 越大)
		 ~:取反
		   将数据转化为二进制后,所有位1-->0 0-->1
		   规律:对一个数取反 相当于对这个数取负数减1
		 ^:将数据转化为二进制补码之后,低位次对齐,高位次不足补0,然后按位异或,将结果转化为10进制显示
		 	 
		 7 ^ 14 = 9
		 0111 --> 7
		 1110 --> 14
		 1001 --> 9
		 
		 7 ^ 9  = 14
		 1110 --> 9
		 
		 规律:
		 	a^b^b = a
		 	b^b = 0
		 	a^0 = a
		 	
		 交换i和j的值:
		 1.利用一个新的变量来记录值 --- 追尾法
		 2.加减法
		   m = i+j; 
		   i = m-i;
		   j = m-j;
		   
		   j = i+j;
		   i = j-i;
		   j = j-i;
		 3.异或法
		   i=i^j;
		   j=i^j; -> i^j^j ->i
		   i=i^j; -> i^j^i ->j
		 注意:位运算只能计算整数的补码形式
	思考题:
		如何判断i是否是2的次幂
		(i-1) & i == 0
	
	三元运算符:
		逻辑值?表达式1:表达式2;
		
		执行顺序:如果逻辑值为true,则执行表达式1,反之执行表达式2;
		
		三元表达式是一个表达式,就意味着有一个计算结果 --- 表示可以用一个变量接收      
		
		double d = a>b?3.2:5;
		
		double d = a>b?2.1:'a';
		
		a>b?true:3; --- 错误
		
		a,b,c --- 获取三个整数中的最大值
		
		方法一:
			int max = a>b?(a>c?a:c):(b>c?b:c); --- 三元表达式的嵌套
		方法二:
			int max = a>b?a:b;
			
			max = max>c?max:c;
	练习:
	1.  >=90 -> A 
		>=80 -> B
		>=70 -> C
		>=60 -> D
		 <60 -> E --- 输出分数对应的等级
	2.判断某一年是平年还是闰年
	     闰年:逢100整除400;其余的整除4	
	      
	解答:	
    1.int score = 90;
	
	  char lv;
	
	  lv = score<60?'E':(score<70?'D':(score<80?'C':(score<90?'B':'A')));
	
	2.int year = 2008;
	  
	  boolean isRunYear;
	  
	  isRunYear = year%100==0?year%400==0:year%4==0;
	  
	
14.从控制台获取数据  

        需要在类之外写导包语句:import java.util.Scanner	
   
   Scanner s = new Scanner(System.in);
   
   int i = s.nextInt();//获取整数
   
   double d = s.nextDouble();//获取浮点数
   
   String str = s.nextLine();//获取字符串
   
15.运算符的优先级

        赋值运算符 优先级最低
   
   ~ 算术 << >> >>> 关系 & | ^ 逻辑 三元 赋值
   
   () ~ ++ == ! * / % + - << >> >>> 关系 & | ^ 逻辑 三元 赋值
   
   int i = 5;
   
   i = i++;//先把i的值5取出来标记为结果,i自增为6,将标记的结果5赋值给i
   
   ~i++//将i的值5取出来进行取反运算 ,同时i自增为6,将取反的结果打印
   
   明日内容:
   	判断结构
   	
   	选择结构
   	
   	循环结构
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
			       