方法
	为了是某一段代码重复使用,将这段代码提取到一个新的结构 --- 方法/函数
	
	方法在定义的时候,需要明确返回值类型以及参数
	
	明确返回值类型 --- 根据方法的执行结果的类型来确定				   
			  --- 如果方法执行之后没有结果,返回值类型就定义为void	
	
	明确参数类型 --- 判断方法在执行的过程中是否有未知量参与运算
	
	定义方法的时候写在()的参数称之为形参,调用方法的时候传入的数据称之为实参.
	
	方法签名 --- 方法名+参数列表
	
	方法的重载:
		在同一个类中定义多个方法名一致而参数列表不同的方法
		
		方法构成重载的时候,调用方法是靠传入的实参来决定调用哪个方法
		
		参数的类型相同 顺序不一致也会构成重载
		
		public void test01(){
			add(1,2.0);
			add(2.0,1);
		}
		
		public static void add(int a,double b){
			System.out.println("1");
		}
		
		public static void add(double b,int a){
			System.out.println("2");
		}
		
		方法在调用的时候遵循的是最相近匹配原则 --- 只要哪个方法的形参和这个实参最相近,就调用哪个方法
		
		为了防止歧义
			若方法重载出现如下情况时
				add(int a,double b)
				add(double b, int a)
			应补齐
				add(int a,int b)
			否则调用方法
				add(2,3)
			会产生歧义	
		
方法的递归
	在方法中调用了自己本身叫做方法的递归
	
	递归核心思想:逆推
	
练习:求n! --- n的阶乘

5! = 5*4*3*2*1 = 120
		
StackOverFlowError --- 栈内存溢出错误 --- 方法在栈内存中执行 
                   --- 递归在使用的时候不能递归层数太深,递归过深会导致栈溢出错误
                   
	从空间上考虑,递归比循环要更加耗费内存;
	从时间上考虑,递归比循环要耗费更多时间;		
	
	---递归的效率要低于循环
	
	方法调用的内存分析???
方法的传值问题	
	
		
		
		
		
		
		
		
		